{"version":3,"sources":["swiftclick.js"],"names":["SwiftClick","contextEl","init","_swiftContextElOriginalClick","_swiftContextEl","addEventListener","hijackedSwiftElClickHandler","onclick","touchStartHandler","clickHandler","event","targetEl","target","nodeName","toLowerCase","touch","changedTouches","_self","options","elements","_currentlyTrackingTouch","useCssParser","checkIfElementShouldBeIgnored","_clickedAlready","stopPropagation","_touchStartPoint","x","pageX","y","pageY","_scrollStartPoint","getScrollPoint","removeEventListener","touchEndHandler","touchCancelHandler","touchend","hasTouchDriftedTooFar","preventDefault","focus","synthesizeClickEvent","el","clickEvent","document","createEvent","initMouseEvent","window","screenX","screenY","clientX","clientY","dispatchEvent","scrollPoint","pageXOffset","body","scrollLeft","documentElement","pageYOffset","scrollTop","classToIgnore","classToForceClick","parentEl","parentNode","shouldIgnoreElement","hasClass","maxDrift","maxTouchDrift","Math","abs","className","classExists","indexOf","swiftDictionary","this","a","div","span","button","minTouchDrift","prototype","setMaxTouchDrift","TypeError","addNodeNamesToTrack","nodeNamesArray","currentNodeName","i","length","replaceNodeNamesToTrack","useParser","attach","define","amd","module","exports"],"mappings":"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","file":"swiftclick.min.js","sourcesContent":["/*\n * @license MIT License (see license.txt)\n */\n\n'use strict';\n\nfunction SwiftClick (contextEl)\n{\n    // if SwiftClick has already been initialised on this element then return the instance that's already in the Dictionary.\n    if (typeof SwiftClick.swiftDictionary[contextEl] !== 'undefined') return SwiftClick.swiftDictionary[contextEl];\n\n    // add this instance of SwiftClick to the dictionary using the contextEl as the key.\n    SwiftClick.swiftDictionary[contextEl] = this;\n\n    this.options =\n    {\n        elements: {a:'a', div:'div', span:'span', button:'button'},\n        minTouchDrift: 4,\n        maxTouchDrift: 16,\n        useCssParser: false\n    };\n\n    var _self                           = this;\n    var _swiftContextEl                 = contextEl;\n    var _swiftContextElOriginalClick    = _swiftContextEl.onclick;\n    var _currentlyTrackingTouch         = false;\n    var _touchStartPoint                = {x:0, y:0};\n    var _scrollStartPoint               = {x:0, y:0};\n    var _clickedAlready                 = false;\n\n\n    // SwiftClick is only initialised if both touch and orientationchange are supported.\n    if ('onorientationchange' in window && 'ontouchstart' in window)\n    {\n        init();\n    }\n\n    function init ()\n    {\n        // check if the swift el already has a click handler and if so hijack it so it get's fired after SwiftClick's, instead of beforehand.\n        if (typeof _swiftContextElOriginalClick === 'function')\n        {\n            _swiftContextEl.addEventListener('click', hijackedSwiftElClickHandler, false);\n            _swiftContextEl.onclick = null;\n        }\n\n        _swiftContextEl.addEventListener('touchstart', touchStartHandler, false);\n        _swiftContextEl.addEventListener('click', clickHandler, true);\n    }\n\n    function hijackedSwiftElClickHandler (event)\n    {\n        _swiftContextElOriginalClick(event);\n    }\n\n    function touchStartHandler (event)\n    {\n        var targetEl = event.target;\n        var nodeName = targetEl.nodeName.toLowerCase();\n        var touch = event.changedTouches[0];\n\n        // don't synthesize an event if the node is not an acceptable type (the type isn't in the dictionary).\n        if (typeof _self.options.elements[nodeName] === 'undefined')\n        {\n            return true;\n        }\n\n        // don't synthesize an event if we are already tracking an element.\n        if (_currentlyTrackingTouch)\n        {\n            return true;\n        }\n\n        // check parents for 'swiftclick-ignore' class name.\n        if (_self.options.useCssParser && checkIfElementShouldBeIgnored(targetEl))\n        {\n            _clickedAlready = false;\n            return true;\n        }\n\n        event.stopPropagation();\n\n        _currentlyTrackingTouch = true;\n\n        // store touchstart positions so we can check for changes later (within touchend handler).\n        _touchStartPoint.x = touch.pageX;\n        _touchStartPoint.y = touch.pageY;\n        _scrollStartPoint = getScrollPoint();\n\n        // only add the 'touchend' listener now that we know the element should be tracked.\n        targetEl.removeEventListener('touchend', touchEndHandler, false);\n        targetEl.addEventListener('touchend', touchEndHandler, false);\n\n        targetEl.removeEventListener('touchcancel', touchCancelHandler, false);\n        targetEl.addEventListener('touchcancel', touchCancelHandler, false);\n    }\n\n    function touchEndHandler (event)\n    {\n        var targetEl = event.target;\n        var touchend = event.changedTouches[0];\n\n        targetEl.removeEventListener('touchend', touchEndHandler, false);\n        \n        _currentlyTrackingTouch = false;\n\n        // don't synthesize a click event if the touchpoint position has drifted significantly, as the user is not trying to click.\n        if (hasTouchDriftedTooFar(touchend))\n        {\n            return true;\n        }\n\n        // prevent default actions and create a synthetic click event before returning false.\n        event.stopPropagation();\n        event.preventDefault();\n\n        _clickedAlready = false;\n\n        targetEl.focus();\n        synthesizeClickEvent(targetEl, touchend);\n\n        // return false in order to surpress the regular click event.\n        return false;\n    }\n\n    function touchCancelHandler(event) {\n        event.target.removeEventListener('touchcancel', touchCancelHandler, false);\n\n        _currentlyTrackingTouch = false;\n    }\n\n    function clickHandler (event)\n    {\n        var targetEl = event.target;\n        var nodeName = targetEl.nodeName.toLowerCase();\n\n        if (typeof _self.options.elements[nodeName] !== 'undefined')\n        {\n            if (_clickedAlready)\n            {\n                _clickedAlready = false;\n\n                event.stopPropagation();\n                event.preventDefault();\n                return false;\n            }\n\n            _clickedAlready = true;\n        }\n    }\n\n    function synthesizeClickEvent (el, touchend)\n    {\n        var clickEvent = document.createEvent('MouseEvents');\n        clickEvent.initMouseEvent('click', true, true, window, 1, touchend.screenX, touchend.screenY, touchend.clientX, touchend.clientY, false, false, false, false, 0, null);\n        \n        el.dispatchEvent(clickEvent);\n    }\n\n    function getScrollPoint ()\n    {\n        var scrollPoint =\n        {\n            x : window.pageXOffset ||\n                document.body.scrollLeft ||\n                document.documentElement.scrollLeft ||\n                0,\n            y : window.pageYOffset ||\n                document.body.scrollTop ||\n                document.documentElement.scrollTop ||\n                0\n        };\n\n        return scrollPoint;\n    }\n\n    function checkIfElementShouldBeIgnored (el)\n    {\n        var classToIgnore = 'swiftclick-ignore';\n        var classToForceClick = 'swiftclick-force';\n        var parentEl = el.parentNode;\n        var shouldIgnoreElement = false;\n        \n        // ignore the target el and return early if it has the 'swiftclick-ignore' class.\n        if (hasClass(el, classToIgnore))\n        {\n            return true;\n        }\n\n        // don't ignore the target el and return early if it has the 'swiftclick-force' class.\n        if (hasClass(el, classToForceClick))\n        {\n            return shouldIgnoreElement;\n        }\n\n        // the topmost element has been reached.\n        if (parentEl === null)\n        {\n            return shouldIgnoreElement;\n        }\n\n        // ignore the target el if one of its parents has the 'swiftclick-ignore' class.\n        while (parentEl)\n        {\n            if (hasClass(parentEl, classToIgnore))\n            {\n                parentEl = null;\n                shouldIgnoreElement = true;\n            }\n            else\n            {\n                parentEl = parentEl.parentNode;\n            }\n        }\n\n        return shouldIgnoreElement;\n    }\n\n    function hasTouchDriftedTooFar (touchend)\n    {\n        var maxDrift = _self.options.maxTouchDrift;\n        var scrollPoint = getScrollPoint();\n\n        return  Math.abs(touchend.pageX - _touchStartPoint.x) > maxDrift ||\n                Math.abs(touchend.pageY - _touchStartPoint.y) > maxDrift ||\n                Math.abs(scrollPoint.x - _scrollStartPoint.x) > maxDrift ||\n                Math.abs(scrollPoint.y - _scrollStartPoint.y) > maxDrift;\n    }\n\n    function hasClass (el, className) {\n\n        var classExists = typeof el.className !== 'undefined' ? (' ' + el.className + ' ').indexOf(' ' + className + ' ') > -1 : false;\n\n        return classExists;\n    }\n}\n\nSwiftClick.swiftDictionary = {};\n\nSwiftClick.prototype.setMaxTouchDrift = function (maxTouchDrift)\n{\n    if (typeof maxTouchDrift !== 'number')\n    {\n        throw new TypeError ('expected \"maxTouchDrift\" to be of type \"number\"');\n    }\n\n    if (maxTouchDrift < this.options.minTouchDrift)\n    {\n        maxTouchDrift = this.options.minTouchDrift;\n    }\n\n    this.options.maxTouchDrift = maxTouchDrift;\n};\n\n// add an array of node names (strings) for which swift clicks should be synthesized.\nSwiftClick.prototype.addNodeNamesToTrack = function (nodeNamesArray)\n{\n    var i = 0;\n    var length = nodeNamesArray.length;\n    var currentNodeName;\n\n    for (i; i < length; i++)\n    {\n        if (typeof nodeNamesArray[i] !== 'string')\n        {\n            throw new TypeError ('all values within the \"nodeNames\" array must be of type \"string\"');\n        }\n\n        currentNodeName = nodeNamesArray[i].toLowerCase();\n        this.options.elements[currentNodeName] = currentNodeName;\n    }\n};\n\nSwiftClick.prototype.replaceNodeNamesToTrack = function (nodeNamesArray)\n{\n    this.options.elements = {};\n    this.addNodeNamesToTrack(nodeNamesArray);\n};\n\nSwiftClick.prototype.useCssParser = function (useParser)\n{\n    this.options.useCssParser = useParser;\n};\n\n// use a basic implementation of the composition pattern in order to create new instances of SwiftClick.\nSwiftClick.attach = function (contextEl)\n{\n    // if SwiftClick has already been initialised on this element then return the instance that's already in the Dictionary.\n    if (typeof SwiftClick.swiftDictionary[contextEl] !== 'undefined')\n    {\n        return SwiftClick.swiftDictionary[contextEl];\n    }\n\n    return new SwiftClick(contextEl);\n};\n\n\n// check for AMD/Module support, otherwise define SwiftClick as a global variable.\nif (typeof define !== 'undefined' && define.amd)\n{\n    // AMD. Register as an anonymous module.\n    define (function()\n    {\n        return SwiftClick;\n    });\n\n}\nelse if (typeof module !== 'undefined' && module.exports)\n{\n    module.exports = SwiftClick;\n}\nelse\n{\n    window.SwiftClick = SwiftClick;\n}\n"]}